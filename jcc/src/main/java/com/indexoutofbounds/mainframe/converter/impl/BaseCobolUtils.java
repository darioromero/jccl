/* $Id$ */
/*
 * Copyright (c) 2005 - 2007 Travis B. Meisenheimer
 * All rights reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 */

package com.indexoutofbounds.mainframe.converter.impl;

import java.text.DecimalFormat;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;

import com.indexoutofbounds.mainframe.converter.MainFrameGlobals;
import com.indexoutofbounds.mainframe.exception.NumberSizeException;
import com.indexoutofbounds.mainframe.exception.Sock7Exception;

/**
 * <p>This class contains converters from fixed decimal byte arrays of packed
 * decimal (COMP-3) and un/signed numbers (NUMERIC) into <code>double</code> 
 * or <code>long</code> as well as converters from <code>long</code>, and 
 * <code>double</code> to packed decimal (COMP-3) and un/signed numbers 
 * (NUMERIC) (byte[]).</p>
 * 
 * <p>Input to convert a COMP-3 or NUMERIC should be in a <code>byte[]</code>, 
 * and you must use a reader which reads in byte[] and not a char[] or int[].</p>
 * 
 * <p>This class has been nearly fully refactored/re-engineered from the original to include
 * support for much larger numbers (both as native <code>double</code> types and as a 
 * <code>String</code>, QuickConversion ability for REALLY large numbers, and making the code
 * legible (commenting, cleaning up useless operations, cleaning up useless parameters).</p>
 * 
 * <p>Notes: If you require conversion of un/signed NUMERIC values or COMP-3 values to return
 * basically an unmodified String representation of the bytes, then use the 
 * <code>convertCOMP3WithHighPrecision</code> and 
 * <code>convertNumericValueWithHighPrecision</code> methods.  These internally use a StringBuffer
 * for storage and everything is just appened as-is.  Leading zeros will be there.</p>
 * 
 * <p>If you need to convert a Java numeric primitive of large precision, you must either modify
 * <code>formatDoubleValue</code> to remove the if-condition to force all values to be run
 * through the DecimalFormat'er.  This will slow things down quite a bit but the results will
 * be accurate.</p>
 * 
 * <p>"You know Cobol is so old, a lot of people would get a listing of the Assembly code
 * generated by the compiler just to get a better picture of what sort of liberties
 * the compiler was taking behind the scenes.  That's how primitive these things were 
 * in the late 60s and early 70s." -- COBOL guru</p>
 * 
 * <p>Examples of how COBOL Stores data:<ul>
 * <li>COBOL format: data : byte layout: Description</li>
 * <li>S9(3) : +999 : F9 F9 C9 : Signed Numeric</li>
 * <li>9(3) : +999 : F9 F9 F9 : Unsigned Numeric</li>
 * <li>S9(3)v99 : +999.99 : F9 F9 F9 F9 C9 : Signed Numeric decimal with two places after decimal</li>
 * <li>S9(3) COMP-3 : +987 : 98 7C: Signed Numeric COMP-3</li>
 * </ul>
 * 
 * @author The Apache Derby Group http://db.apache.org/derby/
 * @author <a href="mailto:travis@indexoutofbounds.com">Travis Meisenheimer</a>
 * 
 * @link http://db.apache.org/derby
 */

public class BaseCobolUtils {
	
	/**
	 * Setting this to anything other than 0 forces the child conversion
	 * classes to do some extreme type checking.
	 * TODO: Remove this in favor of a more general threshold setting
	 */
	protected final static int STRICT_TRANSLATION = 0;

	/**
	 * Anything larger than this is not allowed to be translated because anything
	 * much larger than this and we won't know if the incoming byte[] contains a value
	 * that a double can hold.  We have String returning functions for REALLY big
	 * numbers.
	 * 
	 * This value is equivalent to Math.pow(2, 1008) and should be more than plenty
	 * big enough for anything on a MainFrame.
	 */
	public final static double DOUBLE_MAX_TRANSLATION_VALUE = 2.7430620343968443E303;

	/**
	 * Anything smaller than this is not allowed to be translated because anything
	 * much smaller than this and we won't know if the incoming byte[] contains a value
	 * that a double can hold.  We have String returning functions for REALLY smaller
	 * numbers.
	 * 
	 * This value is equivalent to Math.pow(2, 1008) * -1 and should be more than plenty
	 * big enough for anything on a MainFrame.
	 */
	public final static double DOUBLE_MIN_TRANSLATION_VALUE = DOUBLE_MAX_TRANSLATION_VALUE * -1;

	/**
	 * A precision higher than this would cause the resulting translated value to be higher
	 * than DOUBLE_MAX_TRANSLATION_VALUE.  This also limits the allowed byte[] size to be
	 * less than 155; however we should never get an odd value so 154 is good enough.
	 * 
	 * If we run into problems with this being too low then the 
	 * <code>DOUBLE_MAX_TRANSLATION_VALUE</code> would need to be increased by factors of
	 * two.
	 */
	public final static int DOUBLE_PRECISION_LIMIT = 308;

	/**
	 * How the above numbers were discovered: The max value for a Java double is 2^1024
	 * which in packed bytes is 310 bytes long.  This is too big so we decrement by a full 
	 * byte and we then get 2^1016 which is 309 bytes -- but all packed bytes must be 
	 * evenly divisible by 2 so we then decrement again and get 2^1008 which is 308 bytes 
	 * and a safe value.
	 */

	/**
	 * This is the max value that a packed (COMP-3) byte can hold.  This is equivalent
	 * to the byte containing two nines, 1001 1001.
	 */
	public final static int PACKED_BYTE_MAX_VALUE = 153;

	/**
	 * This is the max value that a numeric byte can hold.  This is equivalent
	 * to the byte containing an F and one nine, 1111 1001.
	 */

	public final static int NUMERIC_BYTE_MAX_VALUE = 159;

	/**
	 * This class does make sure that data is within the above MAX_VALUEs but those values
	 * are large enough for almost anything.
	 */

	/**
	 *  Sign values.
	 */
	public static final char SIGN_POS = 0xC;
	public static final char SIGN_NEG = 0xD;
	public static final char SIGN_UNSIGNED = 0xF;

	public static final byte HEX_NEG = 0x0D;

	/**
	 * Low nybble mask value, 0000 1111
	 */
	public static final byte LOW_NYBBLE_MASK = 0x0F;

	/**
	 * High nybble mask value, 1111 0000
	 */
	public static final int HIGH_NYBBLE_MASK = 0xF0;

	/**
	 * Formatter to strip out SI Notation
	 */
	protected final static DecimalFormat decimalformat = new DecimalFormat(MainFrameGlobals.DOUBLE_FORMAT);
	
	public static final int HIGH_NYBBLE = 0;
	public static final int LOW_NYBBLE = 1;

	/**
	 * Logger this class uses.
	 */
	private static Logger log = Logger.getLogger(BaseCobolUtils.class);

	/**
	 * Don't allow this class to be instantiated.
	 */
	public BaseCobolUtils() {
	}

	// -------------- Private Accessory Methods

	/**
	 * Trivial accessory method which determines the precision of a
	 * packed decimal number. (How many digits the number will be)
	 * 
	 * @param arrayLength - the length of the byte array containing the data
	 */
	protected static int determinePrecision(int arrayLength) {
		
		return (arrayLength * 2) - 1;
	}

	/**
	 * Uses a mask to determine if the sign is negative.
	 * Positive and unsigned return the same (false).
	 * 
	 * Precondition: the signbit is the high nybble in the
	 * last byte (COMP-3)
	 * 
	 * @param signbit the byte which holds the sign
	 * @throws Sock7Exception
	 */

	protected static boolean isNegativeHighNybbleSignBit(byte signbit) throws Sock7Exception {

		int sign = digOutHighNybbleValue(signbit);
		
		if(!checkSign(sign)) {
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_SignBit);
		}
		
		return sign == HEX_NEG;
	}

	/**
	 * Uses a mask to determine if the sign is negative.
	 * Positive and unsigned return the same (false).
	 * 
	 * Precondition: the signbit is the low nybble in the
	 * last byte (NUMERIC)
	 * 
	 * @param signbit the byte which holds the sign
	 * @throws Sock7Exception
	 */
	protected static boolean isNegativeLowNybbleSignBit(byte signbit) throws Sock7Exception {
		
		int sign = digOutLowNybbleValue(signbit);
		
		if(!checkSign(sign)) {
			throw new Sock7Exception(MainFrameGlobals.COBOLConversionUtils_SignBit + ": " + sign);
		}
		
		return (sign == HEX_NEG);
	}

	/**
	 * Trivial accessory method which determines by what number
	 * we multiply something (1 or -1) to set the sign on a Java
	 * int/long/double.
	 * 
	 * Precondition: the signbit is the high nybble (COMP-3)
	 * 
	 * @param signbit byte which holds the sign
	 * @return 1 or -1
	 * @throws Sock7Exception
	 */
	protected static int digOutSignMultiplierHighNybble(byte signbit) throws Sock7Exception {

		return (isNegativeHighNybbleSignBit(signbit)) ? -1 : 1;
	}

	/**
	 * Trivial accessory method which determines by what number
	 * we multiply something (1 or -1) to set the sign on a Java
	 * int/long/double.
	 * 
	 * Precondition: the signbit is the low nybble (NUMERIC)
	 * 
	 * @param signbit byte which holds the sign
	 * @return 1 or -1
	 * @throws Sock7Exception
	 */
	protected static int digOutSignMultiplierLowNybble(byte signbit) throws Sock7Exception {

		return (isNegativeLowNybbleSignBit(signbit)) ? -1 : 1;
	}

	/**
	 * Digs out the value packed in the upper nybble of
	 * a packed decimal
	 * 
	 * @param b the byte
	 * @return and int value between 0-9
	 */
	protected static int digOutHighNybbleValue(byte b) {
		
		return (b & HIGH_NYBBLE_MASK) >>> 4;
	}

	/**
	 * Digs out the value packed in the lower nybble of
	 * a packed decimal
	 * 
	 * @param b the byte
	 * @return and int value between 0-9
	 */
	protected static int digOutLowNybbleValue(byte b) {
		
		return (b & LOW_NYBBLE_MASK);
	}
	
	/**
	 * Busts a byte into an int[] based on the nybbles.  The int[] contains exactly two elements
	 * with the 0 element containing the "high" nybble value and the 1 element containing the
	 * "low" nybble value.
	 * 
	 * @param b - the byte
	 * @return int[] containing the busted-up byte
	 */
	protected static int[] bustByteIntoNybbles(byte b) {
		
		// 1 byte = 2 nybbles, 1 nybble = 4 bits.
		int[] ubyte = new int[2];
		
		ubyte[HIGH_NYBBLE] = digOutHighNybbleValue(b);
		ubyte[LOW_NYBBLE] = digOutLowNybbleValue(b);
		
		return ubyte;
	}
	
	/**
	 * Checks to see if a sign bit holds a potentially valid value.
	 * 
	 * TODO What about "NULLED" fields?
	 * 
	 * @param signbit - the dug out sign bit
	 * @return true/false
	 */
	protected static boolean checkSign(int signbit) {
		
		return (signbit == SIGN_POS || signbit == SIGN_NEG || signbit == SIGN_UNSIGNED || signbit == 0);
	}
	
	/**
	 * Returns true if and only if the conversion value is within
	 * our tolerance of less than DOUBLE_MAX_TRANSLATION_VALUE and
	 * greater than DOUBLE_MIN_TRANSLATION_VALUE
	 * 
	 * @param d double we are converting
	 * @return boolean
	 */
	protected static boolean isWithinTolerance(double d) {

		return (DOUBLE_MIN_TRANSLATION_VALUE <= d && d <= DOUBLE_MAX_TRANSLATION_VALUE);
	}	

	/**
	 * Formats an int into non-scientific notation and
	 * strips out any commas or other junk -- only does this
	 * if the input value is greater than the 
	 * <code>DOUBLE_THRESHOLD</code>
	 * 
	 * @param i the input int
	 * @return String
	 */
	protected static String formatIntValue(int i) {

		if (i > MainFrameGlobals.DOUBLE_THRESHOLD) {
			decimalformat.applyPattern(MainFrameGlobals.INT_FORMAT);
			return decimalformat.format(i);
		} else {
			return String.valueOf(i);
		}
	}
	/**
	 * Formats a double into non-scientific notation and
	 * strips out any commas or other junk -- only does this
	 * if the input value is greater than the 
	 * <code>DOUBLE_THRESHOLD</code>
	 *  
	 * For high precision numbers, we need to format to strip out SI
	 * 
	 * @param d the input double
	 * @return String
	 */
	protected static String formatDoubleValue(double d) {

		if (d > MainFrameGlobals.DOUBLE_THRESHOLD) {
			decimalformat.applyPattern(MainFrameGlobals.DOUBLE_FORMAT);
			return decimalformat.format(d);
		} else {
			return String.valueOf(d);
		}
	}
	
	/**
	 * Converts a normalized String into a packed byte[] -- This actually
	 * creates the packed decimal.
	 * 
	 * @param val - normalized String
	 * @return byte[] reprensentation of a packed decimal
	 */
	protected static byte[] packDataIntoBytes(String val) {

		byte[] bytes = new byte[val.length() / 2];
		int k = 0;
		for (int i = 0; i < val.length(); i += 2) {
			/**
			 * You take the 'high' value and << 4, then you
			 * take the 'low' value and << 128.  Unless we've
			 * hit the last 4 bits which we need to get the hex value
			 * and then process like we did a normal low value.
			 * ('char' - 55)
			 * 
			 * I *could* do this manually, but the below way is easier
			 * and runs just as fast "on my box."
			 */
			bytes[k++] = (byte) Integer.parseInt(val.substring(i, i + 2), 16);
		}
		return bytes;
	}

	/**
	 * Debugging function which breaks up a normalized bit-pattern 
	 * string into byte increments by adding a space every two chars.
	 * 
	 * @param val
	 * @return String
	 */
	protected static String displayInBytePattern(String val) {
		
		StringBuffer sb = new StringBuffer();
		
		for (int i = 0; i < val.length(); i += 2) {
			sb.append(val.substring(i, i + 2));
			sb.append(" ");
		}

		return sb.toString();

	}	
}
